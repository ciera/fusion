#summary How to specify FUSION Constraints
#labels Documentation-Specifications

= Specifying Constraints =
Constraints are written as a class-level Java 5 annotation called `Constraint`. To write multiple constraints on the same class, use the annotation `Constraints` to make an array of `Constraint` annotations. 

=Examples=

{{{
@Constraint(
	op="ListItem.setSelected(boolean selected) : void",
	trigger = "!selected AND Child(target, ctrl) AND ctrl instanceof DropDownList",
	requires = "Selected(target)",
	effects = {"!CorrectlySelected(ctrl)"}
)
}}}

{{{
@Constraint(
	op="EOM",
	trigger = "!CorrectlySelected(ctrl) AND ctrl instanceof DropDownList",
	requires = "FALSE",
	effects = {}
)
}}}

{{{
@Constraint(
	op = "File(String s)",
	trigger = "TRUE",
	requires = "File_GetAbsolutePath(x)",
	effects = {}					
)
}}}

{{{
@Constraint(
	op = "File.getParentFile() : void",
	trigger = "TRUE",
	requires = "File_Init(target)",
	effects = {}
)
}}}

=Syntax=
A constraint has 4 parts:
  # The operator being constrained (Operator)
  # The trigger predicate (Predicate)
  # The requires predicate (Predicate)
  # The effects list (Effects)

The first 3 parts are written as Strings, and the last is an array of Strings. The syntax of these strings is described below. *Bold text* is used to describe required syntax, while _italic text_ is used to describe a 0-n comma separated list.

Notice that the effects list is *not* a predicate; you cannot specify logical operators. It is simply a list of effects. This is because it makes little sense to specify an effect with a disjunction or an implication. Additionally, the effects can only be relationships, not type checks or equality checks.

== Operator syntax ==
Operator ::= !MethodCall | Constructor | EOM<br>
!MethodCall ::= Type*.methodName(*_Type var_ *):* Type<br>
Constructor ::= Type*(*_Type var_*)*<br>
EOM ::=  | *eom*<br>
Type ::= elementalType | typeName<br>

== Predicate syntax ==
Both the trigger predicate and the requires predicate have the same syntax.

Predicate ::= Predicate *IMPLIES* Predicate | Predicate *OR* Predicate | Predicate *AND* Predicate | *(*Predicate*)* | Relationship | Boolean<br>
Relationship ::= *!*Relationship | !TypeRelationship | !EqualityRelationship | !UserRelationship | !TestRelationship<br>
Boolean ::= *TRUE* | *FALSE* | var | *!*var<br>
!TypeRelationship ::= var *instanceof* Type<br>
!EqualityRelationship ::= var *==* var<br>
!UserRelationship ::= relName*(*_var_*)*<br>
!TestRelationship ::= *?*relName*(*_var_*) :* var<br>

== Effects syntax ==

Effect ::= *!*Effect | !UserRelationship | !TestRelationship<br>
!UserRelationship ::= relName*(*_WCVar_*)*<br>
!TestRelationship ::= *?*relName*(*_WCVar_*) :* var<br>
WCVar ::= *`*`* | var<br>