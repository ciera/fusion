#summary How to specify FUSION Constraints
#labels Documentation-Specifications

= Specifying Constraints =
Constraints are written as a class-level Java 5 annotation called `Constraint`. To write multiple constraints on the same class, use the annotation `Constraints` to make an array of `Constraint` annotations. 

=Examples=

{{{
@Constraint(
	op="ListItem.setSelected(boolean selected) : void",
	trigger = "!selected AND Child(target, ctrl) AND ctrl instanceof DropDownList",
	requires = "Selected(target)",
	effects = {"!CorrectlySelected(ctrl)"}
)
}}}

{{{
@Constraint(
		op="EOM(x)",
		trigger = "!CorrectlySelected(ctrl) AND ctrl instanceof DropDownList",
		requires = "FALSE",
		effects = {}
)
}}}

{{{
@Constraint(
	op = "File(String s)",
	trigger = "TRUE",
	requires = "File_GetAbsolutePath(x)",
	effects = {}					
)
}}}

{{{
@Constraint(
	op = "File.getParentFile() : void",
	trigger = "TRUE",
	requires = "File_Init(target)",
	effects = {}
)
}}}

=Syntax=
A constraint has 4 parts:
  # The operator being constrained
  # The trigger predicate
  # The requires predicate
  # The effects list

The first 3 parts are written as Strings, and the last is an array of Strings. (While not ideal, this is due to the limitations of Java 5 annotations.) The syntax of these strings is described below. *Bold text* is used to describe required syntax, while _italic text_ is used to describe a 0-n comma separated list.

== Operator syntax ==
Operator ::= !MethodCall | Constructor | EOM<br>
!MethodCall ::= Type*.methodName(*_Type var_ *):* Type<br>
Constructor ::= Type*(*_Type var_*)*<br>
EOM ::= *eom(* var *)* | *eom*<br>
Type ::= elementalType | typeName<br>

*Note: EOM doesn't  yet work*

 While it will parse, it will not yet match to anything. There is an issue in Crystal that must be fixed first. [http://code.google.com/p/fusion/issues/detail?id=7 Issue 7] has the relevant details.

== Predicate syntax ==
Both the trigger predicate and the requires predicate have the same syntax.

Predicate ::= Predicate *IMPLIES* Predicate | Predicate *OR* Predicate | Predicate *AND* Predicate | *(*Predicate*)* | Relationship | Boolean<br>
Relationship ::= *!*Relationship | !TypeRelationship | !EqualityRelationship | !UserRelationship | !TestRelationship<br>
Boolean ::= *TRUE* | *FALSE* | var | *!*var<br>
!TypeRelationship ::= var *instanceof* Type<br>
!EqualityRelationship ::= var *==* var<br>
!UserRelationship ::= relName*(*_var_*)*<br>
!TestRelationship ::= *?*relName*(*_var_*) :* var<br>

== Effects syntax ==

Effect ::= *!*Effect | !UserRelationship | !TestRelationship<br>
!UserRelationship ::= relName*(*_WCVar_*)*<br>
!TestRelationship ::= *?*relName*(*_WCVar_*) :* var<br>
WCVar ::= *`*`* | var<br>